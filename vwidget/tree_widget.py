# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_tree_widget.ipynb.

# %% ../nbs/02_tree_widget.ipynb 0
from __future__ import annotations
# TODO: check what happens if we uncoment above line

# %% auto 0
__all__ = ['AnyTreePath', 'AnyTreeNode', 'NamedP', 'AnyNodeItem', 'ValueNode', 'FolderNode', 'TreeAdapter', 'AnyTreeWidget',
           'TreeSelect', 'FilesWidget']

# %% ../nbs/02_tree_widget.ipynb 5
import asyncio
from pathlib import Path
from typing import cast
from typing import ClassVar
from typing import Collection
from typing import Generator
from typing import Iterable
from typing import NamedTuple
from typing import Mapping
from typing import Protocol
from typing import Type
from typing import TypeAlias

import ipywidgets as W
import traitlets as T
from ipytree import Node
from ipytree import Tree
from traitlets import Instance
from traitlets import List
from traitlets import observe

from vutil.vario import is_listy
from .base_widget import SelectDetailApp


# %% ../nbs/02_tree_widget.ipynb 12
def _get_name(name: str | None, value) -> str:
    try:
        return name or getattr(value, 'name')
    except AttributeError:
        pass
    return type(value).__name__ if is_listy(value) else str(value)


# %% ../nbs/02_tree_widget.ipynb 13
class NamedP(Protocol):
    @property
    def name(self) -> str: ...

AnyTreePath: TypeAlias = tuple[int, ...]

class AnyNodeItem(NamedTuple):
    path: AnyTreePath
    node: AnyTreeNode

class ValueNode(Node):
    value: object
    # value = T.Instance(klass=object, read_only=True)
    _icon_: ClassVar[str] = 'archive'
    def __init__(self, value:object, name: str | None = None, **kwargs):
        self.value = value
        # self.set_trait('value', value)
        super().__init__(
            _get_name(name, value), 
            icon=kwargs.pop('icon', self._icon_), 
            **kwargs)
    def _repr_keys(self):
        return ('value', 'name', 'selected')
    def __getitem__(self, path):
        raise IndexError(f'ValueNode has no children: {self.name}')
    def _iter(self, at: AnyTreePath | None = None) -> Generator[tuple[AnyTreePath, AnyTreeNode], None, None]:
        yield (at or (), self)

class FolderNode(Node):
    value: Collection[object]
    # value = T.Tuple(read_only=True).tag(trait=T.Instance(object))
    _icon_closed_: ClassVar[str] = 'folder'
    _icon_opened_: ClassVar[str] = 'folder-open'
    _close_icon_: ClassVar[str] = 'chevron-down'
    _open_icon_: ClassVar[str] = 'chevron-right'

    def __init__(self, 
            value: Collection[object], 
            name: str | None = None, 
            nodes: Collection[Node] = (), 
            **kwargs
        ):
        self._to = None
        self.value = value
        # self.set_trait('value', value)
        opened = kwargs.pop('opened', False)
        super().__init__(
            name = _get_name(name, value), 
            nodes = nodes,
            icon = kwargs.pop('icon', self._icon_opened_ if opened else self._icon_closed_), 
            opened = opened,
            close_icon = kwargs.pop('close_icon', self._close_icon_),
            open_icon = kwargs.pop('open_icon', self._open_icon_),
            **kwargs)
    def _repr_keys(self):
        return ('name', 'selected', 'opened',)
    def _iter(self, at: AnyTreePath | None = None) -> Generator[AnyNodeItem, None, None]:
        at = at or ()
        yield AnyNodeItem(at, self)
        for i,node in enumerate(self.nodes):  # type: ignore
            yield from node._iter(at + (i,))
    def __getitem__(self, path: int | AnyTreePath) -> ValueNode | FolderNode:
        path = (path, ) if isinstance(path, int) else path
        node = self.nodes[path[0]]  # type: ignore
        return node if len(path) == 1 else node[path[1:]]

class TreeAdapter:
    _items_str_: ClassVar[str] = 'items'

    @classmethod
    def is_folder(cls, x: object) -> bool:
        if isinstance(x, Collection) and not isinstance(x, (str, bytes)):
            return True
        items = getattr(x, cls._items_str_, None)
        return bool(items and isinstance(items, Iterable))

    @classmethod
    def items(cls, value) -> Generator[tuple[str, object], None, None]:
        if isinstance(value, Mapping):
            for kv in value.items():
                yield kv
        elif isinstance(value, Iterable):
            for v in value:
                yield (_get_name(None, v), v)
        elif hasattr(value, cls._items_str_):
            pp = [(_get_name(None, v), v) for v in value.items]
            pp = sorted(pp, key=lambda x: x[0])
            for p in pp:
                yield p
        else:
            raise TypeError(f"{value = }")

AnyTreeNode: TypeAlias = ValueNode | FolderNode

_FOLDER_SENTINEL = ValueNode(None, name='FOLDER_SENTINEL')

class AnyTreeWidget(Tree):
    source = List(())
    _adapter_: ClassVar[TreeAdapter] = TreeAdapter()
    _value_node_: ClassVar[Type[ValueNode]] = ValueNode
    _folder_node_: ClassVar[Type[FolderNode]] = FolderNode
    
    value = T.Tuple().tag(trait=Instance(Node))
    # selected_nodes = Tuple(read_only=True).tag(trait=Instance(Node),sync=True, **widget_serialization)
    selected_paths = T.Tuple().tag(trait=Instance(tuple))

    def __init__(self, 
            source: Collection[object], 
            adapter: Type[TreeAdapter] | None = None, 
            select: AnyTreePath = (),
            expand: AnyTreePath = (),
            **kwargs):
        if adapter:
            setattr(self, '_adapter_', adapter())
        super().__init__(
            stripes=kwargs.pop('stripes', True), 
            multiple_selection=kwargs.pop('multiple_selection', False), 
            animation=100, 
            **kwargs)
        self.layout.overflow = 'scroll scroll'  # type: ignore
        self.source = source
        self._link = W.dlink((self, 'selected_nodes'), (self, 'value'))
        if select:
            self.select(select)
        if expand:
            self.expand(expand)

    def _setup_node(self, value, name: str | None = None, **kwargs):
        adapter = self._adapter_
        if adapter.is_folder(value):
            nodes = [self._setup_node(v, name=k) for k,v in adapter.items(value)]
            # nodes = [_FOLDER_SENTINEL]
            folder = self._folder_node_(value, name=_get_name(name, value), nodes=nodes, **kwargs)
            folder.observe(self.handle_click, 'opened')  # type: ignore
            return folder
        else:
            return self._value_node_(value, name=name)  
    
    # ---------- traversal
    def _iter(self, at: AnyTreePath | None = None) -> Generator[AnyNodeItem, None, None]:
        for i, node in enumerate(cast(Collection, self.nodes)):
            yield from node._iter((at or ())+(i,))
    
    def find_node(self, value: object) -> AnyTreeNode | None:
        for path, node in self._iter():
            if node.value == value:
                return node
        return None
    def find_all_nodes(self, value: object) -> tuple[AnyTreeNode, ...]:
        return tuple(node for path, node in self._iter() if node.value == value)
    def paths_of_value(self, value: object) -> tuple[AnyTreePath, ...]:
        return tuple(path for path, _ in self._iter() if _.value == value)
    def nodes_of_value(self, value: object) -> tuple[AnyTreeNode, ...]:
        return tuple(node for _, node in self._iter() if node.value == value)
    def path_of_node(self, node: AnyTreeNode) -> AnyTreePath | None:
        for path,_ in self._iter():
            if _ is node:
                return path
        return None
    
    def __getitem__(self, path: int | AnyTreePath) -> AnyTreeNode:
        _path: AnyTreePath = (path, ) if isinstance(path, int) else path
        node = self.nodes[_path[0]]
        return node if len(_path) == 1 else node[_path[1:]]
    
    # ---------- UX
    def handle_click(self, event):
        folder = event['owner']
        # if folder.nodes[0] is _FOLDER_SENTINEL:
        #     adapter = self._adapter_
        #     nodes = [self._setup_node(v, name=k) for k,v in adapter.items(folder.value)]
        #     folder.nodes = nodes
        #     # with self.hold_trait_notifications():
        #     #     # folder.remove_node(_FOLDER_SENTINEL)
        #     #     folder.add_node(nodes[0])
        #     #     folder.add_node(nodes[1])
        #     # loop = asyncio.get_event_loop()
        #     # loop.call_soon(lambda: self.handle_click(event))
        #     return
        folder.icon = folder._icon_opened_ if event['new'] else folder._icon_closed_

    def select(self, path_or_node: AnyTreePath | AnyTreeNode | object, scroll: bool = False):
        if isinstance(path_or_node, tuple):
            nodes = (self[path_or_node], )
        elif isinstance(path_or_node, (ValueNode, FolderNode)):
            nodes = (path_or_node, )
        else:
            nodes = self.nodes_of_value(path_or_node)
        self.value = nodes

    def expand(self, path_or_node: AnyTreePath | AnyTreeNode | object, scroll: bool = False):
        if isinstance(path_or_node, tuple):
            path = path_or_node
        elif isinstance(path_or_node, (ValueNode, FolderNode)):
            path = self.path_of_node(path_or_node)
        else:
            path = ()
            paths = self.paths_of_value(path_or_node)
            if paths:
                path = paths[0]
        if path:
            node = self
            for _ in path:
                node = node[_]
                if not node.opened:
                    node.opened = True
            # self[path].opened = True
        # if scroll:
        #     self.scroll_to_node(node)
    
    @observe('source')
    def _observe_source(self, change):
        source: Collection[object] = change['new']
        nodes, open_folder = [], False
        for v in source:
            n = self._setup_node(v, name=None, opened=open_folder)
            if open_folder and isinstance(n, self._folder_node_):
                open_folder = False
            nodes.append(n)
        self.nodes = nodes

    @observe('value')
    def _observe_value(self, change):
        new_selected = change['new']
        # print(f"{change['old'] = }, {change['new'] = }")
        if new_selected != self.selected_nodes:
            # this code path is taken only when setting the value programmatically
            with self.hold_trait_notifications():
                for node in change['new']:
                    if not node.selected:
                        node.selected = True
                selected = change['old']
                if selected is not T.Undefined:
                    for node in selected:
                        if node.selected:
                            node.selected = False
        # print(f"{self.value =}")
        # # self.notify_change = lambda x: None  # type:ignore[assignment]
        # # try:
        # #     self.selected_paths = tuple(self.path_of_node(_) for _ in self.value)
        # # finally:
        # #     del self.notify_change
        # self.set_trait('selected_nodes', tuple(self.path_of_node(_) for _ in self.value))
        self.selected_paths = tuple(self.path_of_node(_) for _ in self.value)  # type:ignore

    @observe('selected_paths')
    def _observe_selected_paths(self, change):
        new_value = tuple(self[_] for _ in change['new'])
        if new_value != self.value:
            self.value = tuple(self[_] for _ in change['new'])
        

    # @observe('selected_nodes')
    # def _observe_selected_nodes(self, change):
    #     v = change['new']
    #     self.value = tuple(node.value for node in v)
    #     # print(f"value = {self.value}")

    # @property
    # def value(self) -> object | tuple[object, ...] | None: return self._value
    # @value.setter
    # def value(self, values: tuple[object, ...] | None):
    #     vv: tuple[object, ...] = values or ()
    #     if not self.multiple_selection:
    #         vv = vv[:1]
    #     to_select = [self.find(v) for v in vv]
    #     for _ in cast(Collection, self.selected_nodes):
    #         _.selected = False
    #     for _ in to_select:
    #         if _:
    #             _.selected = True
    #     self._value = vv
    #     # print(f"{self._value = }")


# %% ../nbs/02_tree_widget.ipynb 37
class TreeSelect(SelectDetailApp):
    _css = """
        .widget-output .jp-OutputArea {
            background-color: transparent;
            color: var(--vscode-editor-foreground);
        }
        .jstree {background-color: var(--vscode-editor-background) !important;)}
        .jstree-anchor {color: var(--vscode-editor-foreground) !important;)}
        a.jstree-anchor { pointer-events: none; }  # disable click, vscode bug
    """
    def _on_select_change(self, changed):
        nodes = tuple(AnyNodeItem(self.tree.path_of_node(_), _) for _ in changed['new'])  # type: ignore
        self.value = dict(select=nodes)
        self.d()

    # def setup_ux(self, state):
    #     super().setup_ux(state)
    #     tree = self.select
    #     tree.observe(lambda x: self._on_select_change(x), names='selected_nodes')  # type: ignore

        # super()._setup_ux()
        # dcons = self.dcons
        # if dcons:
        #     tree.observe(lambda x: dcons.log(str(tree.value)), names='selected_nodes')  # type: ignore
    
    def __init__(self, 
            data, 
            tree_class: Type[AnyTreeWidget] = AnyTreeWidget, 
            multiple_selection = False,
            expand: AnyTreePath = (),
            select_path: AnyTreePath = (),
            **kwargs
        ):
        self.tree = tree_class(data, multiple_selection=multiple_selection, expand=expand)
        super().__init__(self.tree, **kwargs)
        if select_path:
            loop = asyncio.get_event_loop()
            loop.call_later(0.5, lambda: self.tree.select(select_path))


# %% ../nbs/02_tree_widget.ipynb 50
class FileNode(ValueNode):
    _icon_: ClassVar[str] = 'file'

class FilesTreeAdapter(TreeAdapter):
    @classmethod
    def is_folder(cls, x: Path) -> bool: return not x.is_file()
    @classmethod
    def items(cls, value):
        pp = [(p.name, p) for p in value.iterdir() if not p.name.startswith('.')]
        pp = sorted(pp, key=lambda x: x[0])
        for p in pp:
            yield p


# %% ../nbs/02_tree_widget.ipynb 51
class FilesWidget(AnyTreeWidget):
    _adapter_ = FilesTreeAdapter()
    _value_node_ = FileNode

