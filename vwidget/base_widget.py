# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_base_widget.ipynb.

# %% ../nbs/01_base_widget.ipynb 0
from __future__ import annotations

# %% auto 0
__all__ = ['NOOPDCONS', 'ReflectWidget', 'ThemerWidget', 'WidgetCSS', 'DebugWidgetP', 'BaseExplorerApp', 'DebugWidget',
           'SelectDetailApp', 'ListSelect']

# %% ../nbs/01_base_widget.ipynb 5
import asyncio
import inspect
import pathlib
from functools import partial
from functools import wraps
from typing import Any
from typing import Callable
from typing import cast
from typing import Protocol
from typing import Type
from typing_extensions import Self

import anywidget
import fastcore.all as F
import ipywidgets as W
import traitlets as T
from IPython.display import display

import vwidget
from vutil.imports import AD


# %% ../nbs/01_base_widget.ipynb 9
if F.IN_NOTEBOOK:
    _BUNDLER_PATH = pathlib.Path("src")
else:
    _BUNDLER_PATH = pathlib.Path(inspect.getfile(vwidget)).parent / ("static")


# %% ../nbs/01_base_widget.ipynb 15
def wait_for_change(widget, value):
    future = asyncio.Future()
    def getvalue(change):
        # make the new value available
        future.set_result(change.new)
        widget.unobserve(getvalue, value)
    widget.observe(getvalue, value)
    return future


# %% ../nbs/01_base_widget.ipynb 16
def yield_for_change(widget, attribute):
    """Pause a generator to wait for a widget change event.
        
    This is a decorator for a generator function which pauses the generator on yield
    until the given widget attribute changes. The new value of the attribute is
    sent to the generator and is the value of the yield.
    """
    def f(iterator):
        @wraps(iterator)
        def inner():
            i = iterator()
            def next_i(change):
                try:
                    i.send(change.new)
                except StopIteration as e:
                    widget.unobserve(next_i, attribute)
            widget.observe(next_i, attribute)
            # start the generator
            next(i)
        return inner
    return f


# %% ../nbs/01_base_widget.ipynb 17
class ReflectWidget(anywidget.AnyWidget):
    _id = 0
    _esm = _BUNDLER_PATH / 'reflect.js'
    _css = """
          .reflect-div {
            width: 40ch;
            height: 20px;
            background-image: linear-gradient(to right, #a1c4fd, #c2e9fb);
            # background-image: transparent;
            border: 0;
            # border-radius: 10px;
            # padding: 10px 50px;
            color: white;
          }
          """
    _rid = T.Unicode('').tag(sync=True)  # type: ignore
    ui = T.Bool(False).tag(sync=True)  # type: ignore
    # value = traitlets.Int(0).tag(sync=True)  # type: ignore
    # _html = traitlets.Unicode('').tag(sync=True)  # type: ignore
    query = T.Dict({}).tag(sync=True)

    @property
    def result(self) -> Any | None:
        return self.query['result'] if 'result' in self.query else None  # type: ignore
    
    def get_result(self, query, done: Callable[[Self], None] | None = None) -> asyncio.Future:
        async def f():
          x = await wait_for_change(self, 'query')
          if done:
            loop = asyncio.get_event_loop()
            loop.call_later(0.0, done, self)
        
        self.query = query
        return asyncio.ensure_future(f())
    
    def __init__(self, ui: bool = False, query: dict | None = None, *args, **kwargs):
        if ui: 
          self.ui = ui
        ReflectWidget._id += 1
        self._rid = f"__vutil-reflect-{self._id}"
        super().__init__(*args, **kwargs)
        if query is None:
          return
        self.query = query
        async def f():
          x = await wait_for_change(self, 'query')
        asyncio.ensure_future(f())


# %% ../nbs/01_base_widget.ipynb 28
class ThemerWidget(anywidget.AnyWidget):
    _esm = """
    export function render(view) {
        let div = document.getElementById("__vutil_themer");
        if (!div) {
          div = document.createElement("div");
          div.id = "__vutil_themer";
          div.innerHTML = `themer div`;
          div.style.display = "none";
          view.el.appendChild(div);
        }
        view.model.on("change:value", () => {
          let div = document.getElementById("__vutil_themer");
          div.style.display = view.model.get("ui") ? "block" : "none";
        });
    }
    """

    _css = """
    .cell-output-ipywidget-background {
        background-color: var(--vscode-editor-background) !important;
        # border: 1px solid var(--vscode-editor-background) !important;
        border: 1px solid rgb(53 154 92 / 35%);
    }
    #__vutil_themer {
      height: 20px;
      width: 100px;
      background-color: red;
    }
    """
    ui = T.Bool(False).tag(sync=True)  # type: ignore

class WidgetCSS(anywidget.AnyWidget):
    _esm = None
    def __init__(self, css: str):
        self._css = css
        super().__init__()


# %% ../nbs/01_base_widget.ipynb 38
class DebugWidgetP(Protocol):
    def clear(self, *args): ...
    def log(self, msg): ...
    def log_inc(self, msg=''): ...

class _NoopDebugWidget:
    def clear(self, *args): ...
    def log(self, msg): ...
    def log_inc(self, msg=''): ...
NOOPDCONS = _NoopDebugWidget()

class BaseExplorerApp(W.AppLayout):
    "Base class for ipywidgets composite to explore data"
    _w: AD  # widget subcomponents
    _css = ''
    _exclude = ()
    value = T.Dict({}, read_only=True)
    dcons: DebugWidgetP
    themer: WidgetCSS
    reflect: ReflectWidget
    
    @classmethod
    def _setup_css(cls) -> WidgetCSS | None:
        if not cls._css:
            return None
        if not hasattr(cls, '_css_cls'):
            n, ll = f"{cls.__name__}_CSS", {}
            exec(f"class {n}(WidgetCSS): ...", globals(), ll)
            cls._css_cls:Type[WidgetCSS] = ll[n]
        return cls._css_cls(cls._css)
    def _setup_dcons(self, dcons: bool | DebugWidgetP | None = None) -> DebugWidgetP: ...

    def d(self): pass

    # ---------- ---------- Model ---------- ----------
    def setup_model(self, *args) -> dict[str, Any]:
        """setup model and initial state.
        For our purposes, the model is just a mapping of widget names to actual widget values
        """
        return AD()

    # ---------- ---------- UI view ---------- ----------
    @property
    def widgets(self) -> dict[str, W.DOMWidget]:
        return AD(self._w)
    def _update_ui(self): pass
    def setup_widgets(self, widgets: dict[str, W.DOMWidget] = {}) -> dict[str, W.DOMWidget]:
        return AD(widgets)
    def setup_layout(self):
        # ww = []
        # ensure themer and/or reflect is first
        # try:
        #     ww.append(self._w.themer)
        # except AttributeError:
        #     pass
        # try:
        #     ww.append(self._w.reflect)
        # except AttributeError:
        #     pass
        # # # note widgets are stacked in self._w insertion order
        # # ww.extend([w for k, w in self._w.items() if k not in self._exclude])
        # # base_box = W.Box(
        # #     ww, 
        # #     # layout=W.Layout(
        # #     #     # display='flex',
        # #     #     # flex_flow='row',
        # #     #     # justify_content='flex-start',
        # #     #     # height=f"{height}px",
        # #     #     # border='1px solid red',
        # #     # )
        # # )
        # # return base_box
        # return ww
        if self._w:
            return {'center': W.Box(list(self._w.values()), layout=W.Layout(width='100%', height='100%'))}
        return {}
    
    # ---------- ---------- UX ---------- ----------
    def _setup_state(self, state: dict[str, Any], **kwargs):
        "setup initial values of widgets"
        for k in tuple(kwargs.keys()):
            if k in self._w and k not in self._exclude:
                v = kwargs.pop(k)
                # self._w[k].value = v
                state[k] = v
        # state.update({
        #     k:w.value for k, w in self._w.items() 
        #     if k not in self._exclude and hasattr(w, 'value')})
        return kwargs
    def on_value_change(self, change):
        # print(f"{type(self).__name__}.on_value_change - {change['new']}")
        pass
    def _on_widget_value_change(self, widget_name, change):
        # self.value[widget_name] = change['new']
        # tt = time.perf_counter()
        self.set_trait('value', self.value | {widget_name:change['new']})
        # print(f"{tt} - {type(self).__name__}._on_widget_value_change - {widget_name}: {change['new']}")
    def setup_ux(self, state):
        "state contains initial values of widgets from `setup_model` and defaults from `_defs`"
        # setup initial values of widgets
        for k, v in state.items():
            self._w[k].value = v
        # setup initial app value
        self.set_trait('value', state)
        # setup widget callbacks
        for k,w in self._w.items():
            if k not in self._exclude and hasattr(w, 'value'):
                self._w[k].observe(partial(self._on_widget_value_change, k), names='value')
        self.observe(self.on_value_change, names='value')  # type: ignore
    # ---------- ---------- initialization ---------- ----------
    def show(self):
        ww = []
        try:
            ww.append(self.themer)
        except AttributeError:
            pass
        try:
            ww.append(self.reflect)
        except AttributeError:
            pass
        ww.append(self)
        d = self.dcons
        # if d is not None and d is not NOOPDCONS:
        #     ww.append(cast(Any, d))
        display(W.Box(ww), d) if d is not None and d is not NOOPDCONS else display(W.Box(ww))
    def __init__(self, 
            *model,  # model initial state, forwarded to _setup_model
            show: bool = True, 
            dcons: bool | DebugWidgetP | None = None, 
            reflect: bool = True,
            **kwargs  # widgets items values, forwarded to _setup_values
    ):
        self.dcons = self._setup_dcons(dcons)
        if reflect:
            self.reflect = ReflectWidget()
        if (_ := self._setup_css()):
            self.themer = _
        # ---------- model
        state = self.setup_model(*model)
        # --------- view
        self._w = cast(AD, self.setup_widgets(kwargs.pop('widgets', {})))
        panes = self.setup_layout()
        # ----- defaults
        defs = getattr(type(self), '_defs', None)
        if defs:
            defs.update(kwargs)
            kwargs = defs
        # ----- state
        # self._setup_values(**kwargs)
        kwargs = self._setup_state(state, **kwargs)  # after this, kwargs should only have AppLayout props
        super().__init__(**panes, width=kwargs.pop('width', '100%'), **kwargs)
        # ---------- UX
        if show:
            self.show()
        self.setup_ux(state)
        self.d()



# %% ../nbs/01_base_widget.ipynb 51
class DebugWidget(BaseExplorerApp):
    def clear(self, *args):
        self._w.debug_view.value = ''
    def log(self, msg):
        self._w.debug_view.value = f"{msg}\n{self._w.debug_view.value}"
    def log_inc(self, msg=''):
        first, sep, rest = self._w.debug_view.value.partition('\n')  # type: ignore
        first += '.' + msg
        self._w.debug_view.value = f"{first}\n{rest}"

    # ---------- ---------- UX ---------- ----------
    def setup_ux(self, state):
        super().setup_ux(state)
        self._w.clear_btn.on_click(self.clear)

    def __init__(self, text: str = '', **kwargs):
        kwargs.pop('dcons', None)
        super().__init__(
            debug_view=text, 
            dcons=None, 
            reflect=False, 
            widgets = AD(
                clear_btn = W.Button(
                    description='clear', layout={'position':'absolute','width':'2em'}), 
                debug_view = W.Textarea(
                    value='', layout=W.Layout(width='99.6%', margin='0px', height="100%")), 
            ),
            height = '96px', 
            **kwargs)

@F.patch
def _setup_dcons(self: BaseExplorerApp, dcons: bool | DebugWidgetP | None = None):
    _dcons = NOOPDCONS
    if dcons is True:
        _dcons = DebugWidget(show=False)
    elif isinstance(dcons, DebugWidget):
        _dcons = dcons
    assert isinstance(_dcons, DebugWidget | _NoopDebugWidget)
    _dcons.clear()
    return _dcons


# %% ../nbs/01_base_widget.ipynb 56
class SelectDetailApp(BaseExplorerApp):
    _css = """
        .widget-select select, .widget-output .jp-OutputArea {
        background-color: transparent;
        color: var(--vscode-editor-foreground);
    }
    """
    # ---------- ---------- display ---------- ----------
    def d(self):
        out = self.detail
        # print(self.value)
        if isinstance(out, W.Output):
            v: dict = cast(dict, self.value)
            try:
                out.append_stdout(f"{v['select']}\n")
            except KeyError:
                pass
        
    # ---------- ---------- UI view ---------- ----------
    def setup_layout(self):
        center = W.Box(
                [self.detail],
                layout=W.Layout(
                    height='100%', width='100%', margin='0px', border='0.1px solid red')
            )
        return dict(left_sidebar=self.select, center=center)
    # ---------- ---------- UX ---------- ----------
    def on_value_change(self, change):
        out = self.detail
        # print(f"{time.perf_counter()} - {type(self).__name__}.on_value_changed - {change = }")
        if isinstance(out, W.Output):
            out.clear_output()  # type: ignore
        loop = asyncio.get_event_loop()
        loop.call_later(0.1, self.d)
        # self.d()
    
    # def setup_ux(self, state):
    #     super().setup_ux(state)

    def __init__(self, 
            select: W.DOMWidget, 
            detail: W.DOMWidget | None = None, 
            height: int = 220,
            pane_widths: list[int|str] = [2, 4, 3],
            pane_heights: list[int|str] = [1, 5, 1],
            **kwargs
    ):
        self.detail = W.Output() if detail is None else detail
        self.select = select
        super().__init__(
            widgets = AD(select=self.select, detail=self.detail),
            height = f"{height}px",
            pane_widths = pane_widths,
            pane_heights = pane_heights,
            **kwargs
        )

# %% ../nbs/01_base_widget.ipynb 60
class ListSelect(SelectDetailApp):
    def __init__(self, options, value, **kwargs):
        sel = W.Select(
            options=options,
            layout=W.Layout(width='100%', height='100%', margin='0px', border='0px solid red'),
            disabled=False
        )
        super().__init__(sel, 
                         pane_widths=kwargs.pop('pane_widths', ['120px', 4, 4]), **kwargs)
        sel.value = value
